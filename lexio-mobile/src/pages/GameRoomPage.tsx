import { useParams, useSearchParams, useNavigate } from "react-router-dom";
import { useState, useEffect } from "react";
import { onRoomUpdate, submitTiles, setNextTurn, dealTiles, removeTilesFromHand } from "../lib/roomAPI";
import type { Player } from "../lib/roomAPI";
import { getTileImagePath } from "../utils/tileImage";
import { setPhase as updatePhase } from "../lib/roomAPI";
import { validateTiles } from "../utils/validateTiles";
import { RecommendationPanel } from "../components/RecommendationPanel";
import { compareCombo } from "../utils/compareCombo";
import { settleChips } from "../utils/chipSettlement";
import RoundResultModal from "../components/RoundResultModal";
import { updatePlayerChips } from "../lib/roomAPI";
import { resetRound } from "../lib/roomAPI";
import { remove, ref, get, update } from "firebase/database";
import { db } from "../firebase/firebase";
import { useRef } from "react";

function GameRoomPage() {
  const { roomId } = useParams();
  const [searchParams] = useSearchParams();
  const nickname = searchParams.get("nickname") || "ÏùµÎ™Ö";
  const playerId = searchParams.get("playerId") || "";
  const navigate = useNavigate();

  const [players, setPlayers] = useState<Record<string, Player>>({});
  const [turn, setTurn] = useState("");
  const [playedTiles, setPlayedTiles] = useState<string[]>([]);
  const [myTiles, setMyTiles] = useState<string[]>([]);
  const [selectedTiles, setSelectedTiles] = useState<string[]>([]);
  const [hostId, setHostId] = useState("");
  const [phase, setPhase] = useState("waiting");
  const [turnStartAt, setTurnStartAt] = useState(0);
  const [timeLeft, setTimeLeft] = useState(15);
  const [currentCombo, setCurrentCombo] = useState<string | null>(null);
  const [showRoundModal, setShowRoundModal] = useState(false);
  const [roundLogs, setRoundLogs] = useState<string[]>([]);
  const [roundWinnerId, setRoundWinnerId] = useState<string | null>(null);
  // const [showSubRoundModal, setShowSubRoundModal] = useState(false);
  const previousSubRoundRef = useRef<number>(0);
  // const [subRoundLeaderName, setSubRoundLeaderName] = useState<string>("");

  const isMyTurn = turn === playerId && phase === "playing";

  const toggleTile = (tile: string) => {
    setSelectedTiles((prev) => (prev.includes(tile) ? prev.filter((t) => t !== tile) : [...prev, tile]));
  };

  const handleSubmit = async () => {
    const myType = validateTiles(selectedTiles);
    if (!myType) {
      alert("‚ùå Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ï°∞Ìï©ÏûÖÎãàÎã§. Îã§Ïãú ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.");
      return;
    }

    const prevType = validateTiles(playedTiles);
    if (prevType && myType === prevType) {
      const isStronger = compareCombo(selectedTiles, playedTiles) > 0;
      if (!isStronger) {
        alert("Ïù¥Ï†ÑÎ≥¥Îã§ Í∞ïÌïú Ï°∞Ìï©Îßå ÎÇº Ïàò ÏûàÏäµÎãàÎã§.");
        return;
      }
    }

    const fiveRanks = ["straight", "flush", "fullhouse", "fourcard", "straightflush"];
    if (prevType && myType && prevType !== myType) {
      if (fiveRanks.includes(prevType) && fiveRanks.includes(myType)) {
        const rank = {
          straight: 1,
          flush: 2,
          fullhouse: 3,
          fourcard: 4,
          straightflush: 5,
        };
        if (rank[myType as keyof typeof rank] < rank[prevType as keyof typeof rank]) {
          alert("Îçî ÎÇÆÏùÄ Ï°±Î≥¥Îäî ÎÇº Ïàò ÏóÜÏäµÎãàÎã§.");
          return;
        }
      } else {
        alert("‚ùå Í∞ôÏùÄ Ï°±Î≥¥ ÌÉÄÏûÖÎßå ÎÇº Ïàò ÏûàÏäµÎãàÎã§.");
        return;
      }
    }

    if (!roomId || selectedTiles.length === 0) return;

    await submitTiles(roomId, selectedTiles, playerId);
    await removeTilesFromHand(roomId, playerId, selectedTiles);

    const myHandCount = players[playerId]?.hand?.length ?? 0;
    const isWinner = myHandCount - selectedTiles.length === 0;

    const remainingTiles = myTiles.filter((tile) => !selectedTiles.includes(tile));
    setMyTiles(remainingTiles);
    setSelectedTiles([]);
    setTimeLeft(20);

    if (isWinner) {
      const playerArray = Object.entries(players).map(([id, p]) => ({
        playerId: id,
        nickname: p.nickname,
        hand: id === playerId ? [] : p.hand,
        chips: p.chips ?? 50,
      }));

      const result = settleChips(playerArray);
      const isGameOver = Object.values(result.updatedChips).some((chips) => chips <= 0);

      await updatePlayerChips(roomId, result.updatedChips);
      await update(ref(db, `rooms/${roomId}`), {
        passPlayers: [],
        settlementResult: result,
      });

      if (isGameOver) {
        navigate("/result", { state: result });
      } else {
        setRoundLogs(result.logs);
        setRoundWinnerId(result.winnerId);
        setShowRoundModal(true);
      }

      return;
    }

    await setNextTurn(roomId, playerId, Object.keys(players));
  };

  const handlePass = async () => {
    if (!roomId) return;

    const myHandCount = players[playerId]?.hand.length ?? 0;
    if (myHandCount === 0) {
      const playerArray = Object.entries(players).map(([id, p]) => ({
        playerId: id,
        nickname: p.nickname,
        hand: id === playerId ? [] : p.hand,
        chips: p.chips ?? 50,
      }));

      const result = settleChips(playerArray);
      const isGameOver = Object.values(result.updatedChips).some((chips) => chips <= 0);

      await updatePlayerChips(roomId, result.updatedChips);

      if (isGameOver) {
        navigate("/result", { state: result });
      } else {
        setRoundLogs(result.logs);
        setRoundWinnerId(result.winnerId);
        setShowRoundModal(true);
      }

      return;
    }

    alert("Ìå®Ïä§!");
    await setNextTurn(roomId, playerId, Object.keys(players), true);
    setSelectedTiles([]);
    setTimeLeft(20);
  };

  const handleExit = async () => {
    if (!roomId || !playerId) return;

    const roomRef = ref(db, `rooms/${roomId}`);
    const playerRef = ref(db, `rooms/${roomId}/players/${playerId}`);

    const snapshot = await get(roomRef);
    const roomData = snapshot.val();

    if (confirm("Ï†ïÎßê ÎÇòÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?")) {
      if (roomData.hostId === playerId) {
        // ‚úÖ ÎÇ¥Í∞Ä Ìò∏Ïä§Ìä∏Î©¥ Î∞© Ï†ÑÏ≤¥ ÏÇ≠Ï†ú
        await remove(roomRef);
      } else {
        // ‚úÖ ÎÇ¥Í∞Ä Ìò∏Ïä§Ìä∏Í∞Ä ÏïÑÎãàÎ©¥ ÎÇ¥ ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥Îßå ÏÇ≠Ï†ú
        await remove(playerRef);
      }

      navigate("/lobby");
    }
  };

  const handleNextRound = async () => {
    if (!roomId || !roundWinnerId) return;

    await dealTiles(roomId); // ‚úÖ ÌÉÄÏùº ÏÉàÎ°ú Î∂ÑÎ∞∞
    await resetRound(roomId, roundWinnerId); // ‚úÖ ÎùºÏö¥Îìú Ï¥àÍ∏∞Ìôî (ÌÑ¥, Ìå®Ïä§, ÌÉÄÏù¥Î®∏)

    await update(ref(db, `rooms/${roomId}`), {
      settlementResult: null,
    });

    setShowRoundModal(false); // Î™®Îã¨ Îã´Í∏∞
  };

  useEffect(() => {
    if (!roomId) return;

    const unsubscribe = onRoomUpdate(roomId, (roomData) => {
      (async () => {
        const allPlayers = roomData.players || {};

        const subRoundSignal = roomData.subRoundEnded ?? 0;
        // const leaderName = allPlayers[roomData.turn]?.nickname || "";
        // setSubRoundLeaderName(leaderName);
        // setShowSubRoundModal(true);

        if (subRoundSignal !== previousSubRoundRef.current) {
          previousSubRoundRef.current = subRoundSignal;
        }

        // ‚úÖ passPlayers ÏïàÏ†ÑÌïòÍ≤å Í∞ÄÏ†∏Ïò§Í∏∞
        const passPlayers: string[] = Array.isArray(roomData.passPlayers) ? roomData.passPlayers : [];
        console.log("‚úÖ [passPlayers after fallback]:", passPlayers);

        setPlayers(allPlayers);
        setTurn(roomData.turn);
        setPlayedTiles(roomData.playedTiles || []);
        setHostId(roomData.hostId);
        setPhase(roomData.phase);
        setTurnStartAt(roomData.turnStartAt || 0);

        const myData = allPlayers[playerId];
        if (myData) {
          setMyTiles(myData.hand || []);
        }

        console.log("üß™ [roomData.passPlayers]:", roomData.passPlayers);

        // ‚úÖ Ï§ëÎ≥µ Ï†ïÏÇ∞ Î∞©ÏßÄ: Ïã§Ï†ú ÏäπÏûêÍ∞Ä ÏóÜÍ±∞ÎÇò Ïù¥ÎØ∏ Ï†ïÏÇ∞Îêú ÏäπÏûêÎ©¥ return
        const winnerId = Object.entries(allPlayers).find(([, p]) => p?.hand?.length === 0)?.[0];
        if (!winnerId || winnerId === roundWinnerId) return;

        const playerArray = Object.entries(allPlayers).map(([id, p]) => ({
          playerId: id,
          nickname: p.nickname,
          hand: p.hand,
          chips: p.chips ?? 50,
        }));

        const result = settleChips(playerArray);

        const isGameOver = Object.values(result.updatedChips).some((chips) => chips <= 0);

        await updatePlayerChips(roomId, result.updatedChips);

        if (roomData.settlementResult && !roundWinnerId) {
          const result = roomData.settlementResult;
          setRoundLogs(result.logs);
          setRoundWinnerId(result.winnerId);
          setShowRoundModal(true);
        }

        if (isGameOver) {
          navigate("/result", { state: result });
        } else {
          setRoundLogs(result.logs);
          setRoundWinnerId(result.winnerId);
          setShowRoundModal(true);
        }
      })();
    });

    return () => unsubscribe();
  }, [roomId, playerId]);

  useEffect(() => {
    if (!turnStartAt || !isMyTurn) return;
    let called = false;

    const interval = setInterval(() => {
      const now = Date.now();
      const secondsLeft = 15 - Math.floor((now - turnStartAt) / 1000);
      setTimeLeft(Math.max(0, secondsLeft));

      if (secondsLeft <= 0 && !called) {
        called = true;
        clearInterval(interval);
        handlePass();
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [turnStartAt, isMyTurn]);

  useEffect(() => {
    if (selectedTiles.length === 0) {
      setCurrentCombo(null);
      return;
    }

    const result = validateTiles(selectedTiles);
    setCurrentCombo(result);
  }, [selectedTiles]);

  return (
    <div className="relative w-screen h-screen overflow-x-hidden flex flex-col items-center bg-white text-sm">
      {/* Ï†ÑÏ≤¥ ÎÑàÎπÑÎ•º Ï†úÌïúÌïòÏó¨ Î™®Î∞îÏùº ÌôîÎ©¥ Ï§ëÏïô Ï†ïÎ†¨ */}
      <div className="w-full max-w-md flex flex-col flex-1">
        {/* ÏÉÅÎã® Ï†ïÎ≥¥ ÏòÅÏó≠ */}
        <div className="p-4">
          <div className="flex justify-between items-center mb-2">
            <div className="text-gray-500">
              Î∞© ÏΩîÎìú: <b>{roomId}</b>
            </div>
            <button onClick={handleExit} className="text-red-500 underline">
              ÎÇòÍ∞ÄÍ∏∞
            </button>
          </div>

          <div className="text-center font-bold text-xl mb-2">{nickname}ÎãòÏùò Í≤åÏûÑÎ∞©</div>

          <div className="text-gray-800 mb-2">
            <h3 className="font-semibold mb-1">üë• Ï∞∏Ïó¨Ïûê:</h3>
            <ul className="list-disc list-inside">
              {Object.entries(players).map(([id, player]) => (
                <div
                  key={id}
                  className={`px-3 py-1 rounded-full border mb-1 text-sm ${
                    turn === id ? "bg-green-200 font-bold animate-pulse" : "bg-gray-100"
                  }`}
                >
                  {player.nickname} {id === playerId && "(ÎÇò)"} - üí∞ {player.chips ?? 0}Í∞ú
                </div>
              ))}
            </ul>
          </div>

          <div className="flex justify-center gap-3 mb-2">
            {Object.entries(players).map(([id, player]) => (
              <div
                key={id}
                className={`px-3 py-1 rounded-full border text-sm ${
                  turn === id ? "bg-green-200 font-bold animate-pulse" : "bg-gray-100"
                }`}
              >
                {player.nickname} {id === playerId && "(ÎÇò)"}
              </div>
            ))}
          </div>

          <div className="text-center text-red-500 mb-2">{isMyTurn ? `ÎÇ®ÏùÄ ÏãúÍ∞Ñ: ${timeLeft}Ï¥à` : ""}</div>
        </div>

        {/* ÏÉÅÎåÄ Ìå® Ï†ïÎ≥¥ */}
        <div className="bg-gray-50 p-3 rounded mb-4">
          <h2 className="text-lg font-semibold mb-2">ÏÉÅÎåÄ ÌîåÎ†àÏù¥Ïñ¥</h2>
          {Object.entries(players)
            .filter(([id]) => id !== playerId)
            .map(([id, player]) => (
              <div key={id} className="mb-4">
                <div className="text-md font-semibold">{player.nickname}</div>
                <div className="flex gap-1 mt-1">
                  {Array(player.hand?.length ?? 0)
                    .fill(null)
                    .map((_, i) => (
                      <div key={i} className="w-10 h-14 bg-black rounded-md" />
                    ))}
                </div>
              </div>
            ))}
        </div>
        {/* Ï§ëÏïô Ïä§ÌÅ¨Î°§ ÏòÅÏó≠ */}
        <div className="flex-1 overflow-auto px-4">
          <div className="bg-gray-100 rounded-md p-4 mb-4 text-center min-h-[60px]">
            {playedTiles.length > 0
              ? playedTiles.map((tile, i) => (
                  <span key={i} className="inline-block text-2xl mx-1">
                    <img src={getTileImagePath(tile)} alt={tile} className="w-12 h-auto" />
                  </span>
                ))
              : "Ï†úÏ∂úÎêú ÌÉÄÏùºÏù¥ ÏóÜÏäµÎãàÎã§."}
          </div>

          <div className="flex flex-wrap justify-center gap-2 mb-4">
            {myTiles.map((tile, i) => (
              <button
                key={i}
                onClick={() => toggleTile(tile)}
                className={`text-2xl px-3 py-2 rounded-lg ${
                  selectedTiles.includes(tile)
                    ? "border-4 border-blue-500 bg-blue-300"
                    : "border border-gray-300 bg-yellow-200"
                }`}
              >
                <img src={getTileImagePath(tile)} alt={tile} className="w-12 h-auto" />
              </button>
            ))}
          </div>

          <div className="flex justify-center gap-4 mb-4">
            <button
              onClick={handleSubmit}
              className={`py-2 px-6 rounded-lg text-lg ${
                isMyTurn ? "bg-green-500 text-white" : "bg-gray-300 text-gray-500 cursor-not-allowed"
              }`}
              disabled={!isMyTurn}
            >
              Ï†úÏ∂ú
            </button>
            <button
              onClick={handlePass}
              className={`py-2 px-6 rounded-lg text-lg ${
                isMyTurn ? "bg-gray-400 text-white" : "bg-gray-300 text-gray-500 cursor-not-allowed"
              }`}
              disabled={!isMyTurn}
            >
              Ìå®Ïä§
            </button>
          </div>

          {selectedTiles.length > 0 && (
            <div className="text-center text-sm mb-4">
              {currentCombo ? (
                <span className="text-green-600 font-semibold">‚úÖ ÌòÑÏû¨ ÏÑ†ÌÉùÌïú Ï°∞Ìï©: {currentCombo}</span>
              ) : (
                <span className="text-red-500 font-semibold">‚ùå Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ï°∞Ìï©ÏûÖÎãàÎã§</span>
              )}
            </div>
          )}

          <RecommendationPanel myTiles={myTiles} onSelect={setSelectedTiles} lastPlayedTiles={playedTiles} />
        </div>

        {/* ÌïòÎã® ÏòÅÏó≠ */}
        {playerId === hostId && phase === "waiting" && (
          <div className="w-full text-center p-4">
            <button
              onClick={async () => {
                await dealTiles(roomId!);
                await updatePhase(roomId!, "playing");
              }}
              className="bg-purple-500 text-white px-6 py-2 rounded-lg text-lg"
            >
              üéÆ Í≤åÏûÑ ÏãúÏûë
            </button>
          </div>
        )}

        <RoundResultModal visible={showRoundModal} logs={roundLogs} onClose={handleNextRound} />

        {/* {showSubRoundModal && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-[999]">
            <div className="bg-white p-6 rounded shadow text-center max-w-xs w-[90%]">
              <h2 className="text-xl font-bold mb-2">üåü Î™®ÎëêÍ∞Ä Ìå®Ïä§ÌñàÏäµÎãàÎã§!</h2>
              <p className="text-sm text-gray-700 mb-1">
                <b>{subRoundLeaderName}</b>ÎãòÏù¥ Î®ºÏ†Ä Ìå®Î•º ÌÑ∏ÏóàÏäµÎãàÎã§.<br></br> Îã§Ïãú ÏÑ†Ïù¥ Îê©ÎãàÎã§.
              </p>
              <p className="text-xs text-gray-500 mb-4">ÏÉàÎ°úÏö¥ ÌÑ¥ÏùÑ ÏãúÏûëÌï¥Ï£ºÏÑ∏Ïöî.</p>
              <button
                onClick={() => setShowSubRoundModal(false)}
                className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
              >
                ÌôïÏù∏
              </button>
            </div>
          </div>
        )} */}
      </div>
    </div>
  );
}

export default GameRoomPage;
